name: Signum Agent (Windows) - List certs

on:
  workflow_dispatch:
  push:
    branches: ["main"]
    paths:
      - "filestosign/**"
      - ".github/workflows/**"

permissions:
  contents: read

jobs:
  sign:
    runs-on: windows-latest

    env:
      SIGNUM_REGISTRY: keyfactor.jfrog.io
      SIGNUM_AGENT_IMAGE: keyfactor.jfrog.io/dev-oci/signum-agent:4.20.1

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Docker login (keyfactor.jfrog.io)
        uses: docker/login-action@v3
        with:
          registry: ${{ env.SIGNUM_REGISTRY }}
          username: ${{ secrets.JFROG_USERNAME }}
          password: ${{ secrets.JFROG_TOKEN }}
          logout: true

      - name: Run Signum Agent container, list certs, and extract individual cert blocks
        shell: pwsh
        env:
          SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
          SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}
          SIGNUM_USERNAME: ${{ secrets.SIGNUM_USERNAME }}
          SIGNUM_PASSWORD: ${{ secrets.SIGNUM_PASSWORD }}
          SIGNUM_AGENT_IMAGE: ${{ env.SIGNUM_AGENT_IMAGE }}
        run: |
          $ErrorActionPreference = "Stop"

          try {
            Write-Host "== Basic checks =="
            Write-Host ("Runner OS: " + (Get-CimInstance Win32_OperatingSystem).Caption)
            docker --version | Write-Host

            # Validate required env vars
            $required = @("SIGNUM_HOSTNAME","SIGNUM_CLIENTID","SIGNUM_USERNAME","SIGNUM_PASSWORD","SIGNUM_AGENT_IMAGE")
            $missing = @()
            foreach ($k in $required) {
              $val = [Environment]::GetEnvironmentVariable($k)
              Write-Host ("{0} set? {1}" -f $k, ($(if ([string]::IsNullOrWhiteSpace($val)) { "no" } else { "yes" })))
              if ([string]::IsNullOrWhiteSpace($val)) { $missing += $k }
            }
            if ($missing.Count -gt 0) {
              throw ("Missing required environment variable(s): " + ($missing -join ", "))
            }

            # Ensure sample file(s) exist
            New-Item -ItemType Directory -Force -Path "filestosign" | Out-Null
            if (-not (Test-Path "filestosign\example-script.ps1")) {
              'Write-Host "Hello from Signum signing demo"' | Out-File -FilePath "filestosign\example-script.ps1" -Encoding utf8
            }

            # Pull & run container
            docker pull $env:SIGNUM_AGENT_IMAGE
            docker rm -f signum-agent 2>$null | Out-Null

            $hostMount = (Resolve-Path "filestosign").Path -replace '\\','/'
            docker run --name signum-agent -d `
              -v "${hostMount}:/mnt/filestosign" `
              -e "SIGNUM_HOSTNAME=$env:SIGNUM_HOSTNAME" `
              -e "SIGNUM_CLIENTID=$env:SIGNUM_CLIENTID" `
              -e "SIGNUM_USERNAME=$env:SIGNUM_USERNAME" `
              -e "SIGNUM_PASSWORD=$env:SIGNUM_PASSWORD" `
              -e "SIGNUM_LOGLEVEL=HIGH" `
              -e "SIGNUM_LOGTYPE=FILE" `
              $env:SIGNUM_AGENT_IMAGE | Out-Null

            # Wait for container to be up and `signum-util lc` to succeed (retry loop)
            $maxAttempts = 8
            $delaySeconds = 5
            $ok = $false
            for ($i = 1; $i -le $maxAttempts; $i++) {
              try {
                docker exec signum-agent signum-util lc | Tee-Object -FilePath "signum-certs.txt" | Out-Null
                if ($LASTEXITCODE -ne 0) { throw "non-zero exit" }
                $ok = $true
                break
              } catch {
                Write-Host "Attempt $i/$maxAttempts failed. Waiting $delaySeconds seconds..."
                Start-Sleep -Seconds $delaySeconds
              }
            }
            if (-not $ok) {
              Write-Host "signum-util lc failed after retries. Dumping container logs:"
              docker logs signum-agent
              throw "Failed to list certs from Signum agent."
            }

            # Parse signum-certs.txt to extract certificate blocks.
            $raw = Get-Content -Raw -Path "signum-certs.txt" -ErrorAction Stop
            $normalized = $raw -replace "`r`n", "`n"
            $blocks = -split $normalized, "(`n){2,}"

            $certKeywords = @("Subject","Issuer","Thumbprint","Serial","CN=","Certificate","Public Key","Key ID","NotBefore","NotAfter")
            New-Item -ItemType Directory -Force -Path "certs" | Out-Null

            $certIndex = @()
            $n = 0
            foreach ($b in $blocks) {
              $trimmed = $b.Trim()
              if ([string]::IsNullOrWhiteSpace($trimmed)) { continue }

              # Exclude obvious filename-only blocks
              if ($trimmed -match '^[\w\-\\/:]+\.(txt|log|json)$') { continue }
              if ($trimmed -match '^[\s\S]{0,120}$' -and ($trimmed -notmatch '\s')) { continue }

              # Heuristic: contain cert-like keyword?
              $hasKeyword = $false
              foreach ($kw in $certKeywords) {
                if ($trimmed -match [regex]::Escape($kw)) { $hasKeyword = $true; break }
              }
              if (-not $hasKeyword) {
                if (-not ($trimmed -match '=' -or $trimmed -match '/')) { continue }
              }

              $n++
              $outFile = "certs\cert-$n.txt"
              $trimmed | Out-File -FilePath $outFile -Encoding utf8

              # Build summary line
              $summaryLine = $null
              if ($trimmed -match 'CN=([^,\r\n]+)') { $summaryLine = "CN=" + $matches[1].Trim() }
              elseif ($trimmed -match 'Subject\s*:\s*(.+)') { $summaryLine = "Subject: " + $matches[1].Trim() }
              else { $summaryLine = ($trimmed -split "`n" | Where-Object { $_.Trim() } | Select-Object -First 1).Trim() }

              $certIndex += [PSCustomObject]@{ File = $outFile; Summary = $summaryLine }
            }

            if ($certIndex.Count -eq 0) {
              Write-Host "No certificate blocks matched parsing heuristics. Falling back to raw non-empty lines."
              $lines = Get-Content -Path "signum-certs.txt" | Where-Object { -not [string]::IsNullOrWhiteSpace($_) -and ($_ -notmatch '^\s*#') -and ($_ -notmatch '\.txt$') }
              $lines | Out-File -FilePath "certs/raw-lines.txt" -Encoding utf8
              "### Signum cert listing (raw lines fallback)" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
              "```" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
              Get-Content "certs/raw-lines.txt" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
              "```" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
            } else {
              "### Signum agent: individual certs (saved to certs/)" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
              "```" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
              $i = 0
              foreach ($c in $certIndex) {
                $i++; ("[{0}] {1}" -f $i, $c.Summary) | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
              }
              "```" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
            }
          }
          finally {
            docker rm -f signum-agent 2>$null | Out-Null
          }

      - name: Upload certs artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: signum-certs
          path: |
            signum-certs.txt
            certs/**
